package main

import (
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/types/descriptorpb"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"
	"text/template"
)

const MsgTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{.PackageName}}

import (
	"google.golang.org/protobuf/proto"
	"grpc_demo/io"
	{{.PbPackageName}} {{.PbPackagePath}}
)
{{if .Process}}var Process{{.MsgName}} func(msg *{{.MsgName}}) error

func init() {
	Process{{.MsgName}} = func(m *{{.MsgName}}) error { panic("unimplemented") }
}{{end}}

type {{.MsgName}} struct {
	pb      *{{.PbPackageName}}.{{.MsgName}}
	url     string
	pvId    uint32
	session io.Session
	ctx     any
}

func New{{.MsgName}}() *{{.MsgName}} {
	return &{{.MsgName}}{
		pb: &{{.PbPackageName}}.{{.MsgName}}{},
	}
}


func (msg *{{.MsgName}}) SetSession(session io.Session) {
	msg.session = session
}

func (msg *{{.MsgName}}) GetSession() io.Session {
	return msg.session
}

func (msg *{{.MsgName}}) Marshal() ([]byte, error) {
	return msg.pb.MarshalVT()
}

func (msg *{{.MsgName}}) Unmarshal(bytes []byte) error {
	return msg.pb.UnmarshalVT(bytes)
}

func (msg *{{.MsgName}}) GetType() string { return msg.url }

func (msg *{{.MsgName}}) GetPvId() uint32 { return msg.pvId }

func (msg *{{.MsgName}}) GetContext() any { return msg.ctx }

func (msg *{{.MsgName}}) GetPB() proto.Message {
	return msg.pb
}

func (msg *{{.MsgName}}) TypedPB() *{{.PbPackageName}}.{{.MsgName}} {
	return msg.pb
}

func (msg *{{.MsgName}}) Process() error {
{{if .Process}}return Process{{.MsgName}}(msg){{else}}panic("unimplemented"){{end}}
}

func (msg *{{.MsgName}}) Dispatch() error {
	return nil
}`

const MsgCreatorTemplate = `// Code generated by go generate; DO NOT EDIT.
package msg

import (
	"grpc_demo/io"
{{range $pkg, $path := .ImportSet}}
	{{$pkg}} {{$path}}
{{end}}
)

var Creator = map[string]func() io.Msg{
{{range .MsgInfos}}
	{{if .Process}}{{.TypeUrl}}: func() io.Msg { return {{.PackageName}}.New{{.MsgName}}() },{{end}}
{{end}}
}`

const ProcessorTemplate = `package hello

import (
	hellomsg "grpc_demo/common/msg/gen/hello"
)

func init() {
	hellomsg.ProcessCHello = ProcessCHello
}

func ProcessCHello(msg *hellomsg.CHello) error {

	return nil
}
`

type MsgInfo struct {
	PackageName   string
	MsgName       string
	PbPackageName string
	PbPackagePath string
	TypeUrl       string
	Process       bool
	PathName      string
}

func main() {
	info, ok := debug.ReadBuildInfo()
	if !ok {
		log.Fatal("could not read build info")
	}
	projectName := info.Main.Path

	protoGenPath := "proto/gen"

	bytes, err := os.ReadFile(filepath.Join(".", protoGenPath+"/protos.desc"))
	if err != nil {
		log.Fatalf("Failed to read descriptor set file: %v", err)
	}
	fds := &descriptorpb.FileDescriptorSet{}
	if err := proto.Unmarshal(bytes, fds); err != nil {
		log.Fatalf("Failed to unmarshal descriptor set: %v", err)
	}

	var msgInfos []*MsgInfo

	for _, fd := range fds.GetFile() {
		file, err := protodesc.NewFile(fd, nil)
		if err != nil {
			log.Fatalf("Failed to load file descriptor: %v", err)
		}
		messages := file.Messages()
		for i := 0; i < messages.Len(); i++ {
			msgInfo := &MsgInfo{}
			gp := fd.GetOptions().GetGoPackage()
			parts := strings.Split(gp, ";")
			msgInfo.PbPackageName = parts[1]
			msgInfo.PathName = strings.Split(filepath.Base(fd.GetName()), ".")[0]
			msgInfo.PackageName = msgInfo.PathName + "msg"
			msgInfo.PbPackagePath = "\"" + projectName + "/" + protoGenPath + "/" + msgInfo.PathName + "\""

			msgDesc := messages.Get(i)
			fullMessageName := msgDesc.FullName()
			typeURL := string(fullMessageName)
			msgInfo.MsgName = string(msgDesc.Name())
			msgInfo.TypeUrl = "\"" + typeURL + "\""
			msgInfo.Process = !strings.HasPrefix(msgInfo.MsgName, "S")

			msgInfos = append(msgInfos, msgInfo)
		}
	}
	importSet := make(map[string]string)
	for _, msgInfo := range msgInfos {
		tmpl, err := template.New("msg").Parse(MsgTemplate)
		if err != nil {
			log.Fatalf("Failed to parse template: %v", err)
		}
		path := "common/msg/gen/" + msgInfo.PathName + "/"
		if _, err := os.Stat(path); os.IsNotExist(err) {
			err := os.MkdirAll(path, os.ModePerm)
			if err != nil {
				log.Fatalf("Failed to create directory: %v", err)
			}
		}
		create, err := os.Create(path + strings.ToLower(msgInfo.MsgName) + ".msg.go")
		if err != nil {
			log.Fatalf("Failed to create file: %v", err)
		}
		err = tmpl.Execute(create, msgInfo)
		if err != nil {
			log.Fatalf("Failed to execute template: %v", err)
		}
		log.Printf("Generated file: %s", strings.ToLower(msgInfo.MsgName+".msg.go"))
		importSet[msgInfo.PackageName] = "\"" + projectName + "/" + path[:strings.LastIndex(path, "/")] + "\""

		if msgInfo.Process {

		}

	}
	type MsgInfos struct {
		MsgInfos  []*MsgInfo
		ImportSet map[string]string
	}
	create, err := os.Create("common/msg/gen/creator.go")
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	tmpl, err := template.New("msg").Parse(MsgCreatorTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}
	err = tmpl.Execute(create, &MsgInfos{msgInfos, importSet})
	if err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}
	log.Printf("Generated file: %s", "common/msg/gen/creator.go")
}
