package main

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"io"
	"math/big"
	"net"
	"reares/pkg/rc4"
	"reares/pkg/rsa"
)

func main() {
	//logic.Init()
	//acceptor := io.NewAcceptor("127.0.0.1", "18290")
	//err := acceptor.Start()
	//if err != nil {
	//	log.Fatal(err)
	//}
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		panic(err)
		return
	}
	defer listener.Close()
	println("Server is running on port 8080")

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("Error accepting connection:", err)
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	// RSA KEY EXCHANGE
	session := &Session{
		rsa: rsa.GetInstance(),
	}
	encoded, err := session.rsa.GetPublicKeyEncoded()
	if err != nil {
		println(err)
		return
	}
	_, _ = conn.Write(encoded)

	buffer := new(bytes.Buffer)

	for {
		n, err := buffer.ReadFrom(conn)
		if err != nil {
			if err != io.EOF {
				println(err)
			}
			break
		}
		if n == 0 {
			continue
		}
		if session.securityDecoder != nil {
			// 流加密解密
			session.securityDecoder.DoUpdate(buffer.Bytes())
		}
		if buffer.Len() < 4 {
			continue
		}
		frameLength := binary.BigEndian.Uint32(buffer.Bytes()[:4])
		if int(frameLength)+4 < buffer.Len() {
			continue
		}
		frame := make([]byte, int(frameLength)+4)
		buffer.Read(frame)
		typeId := binary.BigEndian.Uint32(frame[4:8])
		switch typeId {
		case 1:
			// RSA KEY EXCHANGE
			clientPublicKey := frame[8:]
			key := randomKey(32)
			base64.StdEncoding.Encode(key, key)
			session.securityDecoder = rc4.NewRC4(key)
			encrypt, err := rsa.Encrypt(clientPublicKey, key)
			if err != nil {
				println(err)
				return
			}
			send := make([]byte, 4+len(encrypt))
			// length
			binary.BigEndian.PutUint32(send, uint32(len(encrypt)))
			// typeId
			binary.BigEndian.PutUint32(send, 2)
			send = append(send, encrypt...)
			_, _ = conn.Write(send)
		case 2:
			// KEY EXCHANGE
			encrypt := frame[8:]
			clientKey, err := rsa.Decrypt(session.rsa.GetPrivateKey(), encrypt)
			if err != nil {
				println(err)
				return
			}
			session.securityEncoder = rc4.NewRC4(clientKey)
			msg := []byte("hello")
			send := make([]byte, 4+len(msg))
			// length
			binary.BigEndian.PutUint32(send, uint32(len(msg)))
			// typeId
			binary.BigEndian.PutUint32(send, 3)
			send = append(send, msg...)
			session.securityDecoder.DoUpdate(send)
			_, _ = conn.Write(send)
		}
	}
}

type Session struct {
	rsa             *rsa.Key
	securityDecoder *rc4.RC4
	securityEncoder *rc4.RC4
}

func randomKey(size int) []byte {
	res := make([]byte, size)
	str := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	for i := 0; i < size; i++ {
		n, err := rand.Int(rand.Reader, big.NewInt(int64(len(str))))
		if err != nil {
			return nil
		}
		res[i] = str[n.Int64()]
	}
	return res
}
