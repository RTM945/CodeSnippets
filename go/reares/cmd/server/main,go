package main

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"reares/pkg/rc4"
	"reares/pkg/rsa"
)

func main() {

	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		panic(err)
		return
	}
	defer listener.Close()
	println("Server is running on port 8080")

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("Error accepting connection:", err)
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	// RSA KEY EXCHANGE
	session := &Session{
		rsa: rsa.GetInstance(),
	}
	encoded, err := session.rsa.GetPublicKeyEncoded()
	if err != nil {
		println(err)
		return
	}
	send := make([]byte, 4+len(encoded))
	// length
	binary.BigEndian.PutUint32(send[:4], uint32(len(encoded)))
	// typeId
	binary.BigEndian.PutUint32(send[4:8], 1)
	send = append(send, encoded...)
	_, _ = conn.Write(send)

	buffer := new(bytes.Buffer)

	for {
		n, err := buffer.ReadFrom(conn)
		if err != nil {
			if err != io.EOF {
				println(err)
			}
			break
		}
		if n == 0 {
			continue
		}
		if session.securityDecoder != nil {
			// 流加密解密
			session.securityDecoder.DoUpdate(buffer.Bytes())
		}
		if buffer.Len() < 4 {
			continue
		}
		frameLength := binary.BigEndian.Uint32(buffer.Bytes()[:4])
		if buffer.Len() < int(frameLength)+4 {
			continue
		}
		frame := make([]byte, int(frameLength)+4)
		buffer.Read(frame)
		typeId := binary.BigEndian.Uint32(frame[4:8])
		switch typeId {
		case 1:
			// RSA KEY EXCHANGE
			clientPublicKey := frame[8:]
			key := randomKey(32)
			encodedKey := make([]byte, base64.StdEncoding.EncodedLen(len(key)))
			base64.StdEncoding.Encode(encodedKey, key)
			session.securityDecoder = rc4.NewRC4(encodedKey)
			encrypt, err := rsa.Encrypt(clientPublicKey, encodedKey)
			if err != nil {
				println(err)
				return
			}
			send := make([]byte, 4+len(encrypt))
			// length
			binary.BigEndian.PutUint32(send[:4], uint32(len(encrypt)))
			// typeId
			binary.BigEndian.PutUint32(send[4:8], 2)
			send = append(send, encrypt...)
			_, _ = conn.Write(send)
		case 2:
			// KEY EXCHANGE
			encrypt := frame[8:]
			clientKey, err := rsa.Decrypt(session.rsa.GetPrivateKey(), encrypt)
			if err != nil {
				println(err)
				return
			}
			session.securityEncoder = rc4.NewRC4(clientKey)
			msg := []byte("hello")
			send := make([]byte, 4+len(msg))
			// length
			binary.BigEndian.PutUint32(send[:4], uint32(len(msg)))
			// typeId
			binary.BigEndian.PutUint32(send[4:8], 3)
			send = append(send, msg...)
			session.securityDecoder.DoUpdate(send)
			_, _ = conn.Write(send)
		}
	}
}

type Session struct {
	rsa             *rsa.Key
	securityDecoder *rc4.RC4
	securityEncoder *rc4.RC4
}

func randomKey(size int) []byte {
	//res := make([]byte, size)
	//str := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	//for i := 0; i < size; i++ {
	//	n, err := rand.Int(rand.Reader, big.NewInt(int64(len(str))))
	//	if err != nil {
	//		return nil
	//	}
	//	res[i] = str[n.Int64()]
	//}
	//return res
	res := make([]byte, size)
	rand.Read(res)
	return res
}
