package algorithms.dp;

//问题描述：
//设有一个正整数的序列：b1, b2,..., bn
//对于下标i1 < i2 < ... < ih, 若有bi1 < bi2 < ... < bih，则称存在一个长度为h的不下降序列。
//例如下列数
//13  7  9  16  38  24  27  38  44  49  21  52  63  15
//对于下标 i1 = 0,i2 = 3,i3 = 4,i4 = 8,i5 = 12,  且满足
//13 < 16 < 38 < 44 < 63
//则存在长度为5的不下降序列。
//但是，我们看到还存在其它的不下降序列。如
//7 < 9 < 16 < 18 < 19 < 21 < 22 < 63
//则存在长度为8的不下降序列。
//问题：当给定b1, b2, ..., bn后，求出最长的不下降序列h及这个序列中的各个数。
//LIS
public class DP_2 {
    // 设f(i)为以bi结束的最长不下降序列
    // 比如f(12)为63结束的最长不下降序列
    // f(12) = max(f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9), f(10),
    // f(11))
    // f(11) = max(f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8), f(9), f(10))
    // 以此类推，f(i)有i-1个子问题
    // 递归通式
    // f(i) = Max{f(j)+1 | j < i and bj <= bi}
    // 边界条件
    // f(0) = 1
    public static int LIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int result = 1;// 每一位都是长度为1的不下降序列
        for (int i = 1; i < nums.length; i++) {
            /*
             * if(nums[i] > nums[i - 1]) { //如果后一位大于前一位，说明可以构成不下降序列 //其长度为子不下降序列长度+1
             * //但这一步做法是错误的，没有考虑周全 //忽略了类似3, 1 ,4, 2, 5, 7这样的情况 //只能应用于连续递增，无跳跃的情况 dp[i] =
             * dp[i - 1] + 1; }
             */
            // 正确做法是nums[i]需要和前面的每一位进行判断
            // 一次子循环可以得出在i范围内的最长不下降序列
            // 也就是f(i)，需要将其存入dp
            int max = 0;
            for (int j = 0; j < i; j++) {
                // 当后一位大于前一位时，只能形成长度为1的不下降序列
                // 但如果后一位小于前一位满足条件
                // 则将其子问题的解+1作为本次f(i)的解
                // 子问题的解也就是f(0)...f(i-1)的最大值
                // 就是max
                if (nums[i] > nums[j]) {
                    if (max < dp[j]) {
                        max = dp[j];
                    }
                }
                // 这一步其实很迷惑，为什么要写在判断外？
                // 会不会出现一直累加的情况？
                // 如果循环内没有不下降序列
                // 那么max为0，dp[i]=1，对应不下降序列只有nums[i]一位的情况
                // 如果循环内有不下降序列
                // 如果nums[i] > nums[j]，dp[i] = max + 1没有任何问题
                // 如果其中有nums[i] < nums[j]的情况
                // 1, 3, 2希望的dp是[1, 2, 2] i = 2 dp[0] = 1
                // 第一遍循环j = 0，dp=[1, 2, 0] max = dp[0] = 1
                // 第二遍循环j = 1，dp=[1, 2, 2] max = dp[1] = 2
                // 但这里并没有将新的dp[i]赋值给max
                // 也就是说max始终是f(j)的最优解
                // 所以此处没有错误
                dp[i] = max + 1;
                // 与全局最优比较
                if (result < dp[i]) {
                    result = dp[i];
                }
            }
        }
        return result;
        // 这个解法的时间复杂度是O(n^2)
        // 还有O(nlogn)的解法，但不属于DP
    }
}
