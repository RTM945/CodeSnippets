package algorithms.leetcode._2029_stone_game_ix;

public class _2029 {
    // Alice 和 Bob 再次设计了一款新的石子游戏。
    // 现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。
    // 给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。

    // Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。

    // 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
    // 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
    // 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。

    // 来源：力扣（LeetCode）
    // 链接：https://leetcode-cn.com/problems/stone-game-ix
    // 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

    // 博弈论！
    // 将石子分为除 3 余 0 1 2 三种
    // 移除类型 0 石子对石子总和不会有影响 可以看成 先后手 交换
    // 如果类型 0 的石子的个数为偶数，那么胜负情况等价于没有类型 0 的石子的胜负情况；
    // 如果类型 0 的石子个数为奇数，那么胜负情况等价于只有 1 个类型 0 的石子的胜负情况。
    // 再考虑类型 1 和类型 2 的石子
    // 如果 Alice 首先移除类型 1 的石子，那么 Bob 只能移除类型 1 的石子，
    // 在这之后 Alice 只能移除类型 2 的石子，Bob 同样只能移除类型 1 的石子。
    // 以此类推，移除石子的类型序列为：1121212121⋯
    // 如果 Alice 首先移除类型 2 的石子 
    // 类似得到移除石子的类型序列为：2212121212⋯
    
    // 作为先手的 Alice 可以在二者中选择一个序列。
    // 例如 Alice 选择第一种，那么 Bob 永远移除类型 1 的石子，Alice 除了第一步移除类型 1 的石子之外，
    // 后续永远移除类型 2 的石子。因此 Alice 可以获胜当且仅当：
    // 类型 1 的石子恰好有 1 个，并且类型 2 的石子至少有 1 个。此时 Alice 在 Bob 完成第一步时获胜；
    // 类型 1 的石子至少有 2 个，并且不能比类型 2 的石子多：
    // 归纳为同一个条件，即有类型 1 的石子，并且不能比类型 2 的石子多。
    
    // 如果选择第二种
    // 获胜当且仅当有类型 2 的石子，并且不能比类型 1 的石子多。
    // 归纳为同一种情况，即类型 1 和类型 2 的石子至少都有 1 个。

    // 得到 Alice 获胜条件
    // 如果类型 0 的石子的个数为偶数，那么 Alice 获胜当且仅当类型 1 和类型 2 的石子至少都有 1 个；
    // 如果类型 0 的石子的个数为奇数，那么 Alice 获胜当且仅当
    //「在没有类型 0 石子的情况下，Bob 获胜且原因不是因为所有石子都被移除」。
    // 对应到上面的分析即为「类型 1 的石子比类型 2 多超过 2 个」或者
    // 「类型 2 的石子比类型 1 多超过 2 个」。

    class Solution {
        public boolean stoneGameIX(int[] stones) {
            int cnt0 = 0, cnt1 = 0, cnt2 = 0;
            for (int val : stones) {
                int type = val % 3;
                if (type == 0) {
                    ++cnt0;
                } else if (type == 1) {
                    ++cnt1;
                } else {
                    ++cnt2;
                }
            }
            if (cnt0 % 2 == 0) {
                return cnt1 >= 1 && cnt2 >= 1;
            }
            return cnt1 - cnt2 > 2 || cnt2 - cnt1 > 2;
        }
    }
    
}
