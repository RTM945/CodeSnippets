package algorithms.leetcode._174_dungeon_game;

import java.util.Arrays;

//一些恶魔抓住了公主（P）并将她关在了地下城的右下角。
//地下城是由 M x N 个房间组成的二维网格。
//我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
//骑士的初始健康点数为一个正整数。
//如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
//有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数
//若房间里的值为负整数，则表示骑士将损失健康点数
//其他房间要么是空的（房间里的值为 0），
//要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
//为了尽快到达公主，骑士决定每次只向右或向下移动一步。
//编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
//例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
//-2 (K) -3	3
//-5	-10	1
//10	30	-5 (P)
//说明:
//骑士的健康点数没有上限。
//任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，
//包括骑士进入的左上角房间以及公主被监禁的右下角房间。
public class _174 {
    //hard 令人意识模糊
    //本质应该是求最优路径上结点的和
    //那就是用dp
    //063的思路
    //要达到右下P，必是从上面或左面走过来
    //设dp[i][j]为从起点到当前结点的最优路径的和
    //为dp[i-1][j] + dungeon[i][j]或dp[i][j - 1] + dungeon[i][j]
    //dp[0][0] = dungeon[0][0]
    //那么这种思路就是从起点到终点，与贪心法无异
    //然鹅参看DP_1 局部最优不一定是全局最优
    //所以要从后往前递归看
    //但从后往前dp[i][j]就不知道dp[i - 1][j]和dp[i][j - 1]的值了。需要重新思考
    //另一个不采用从前往后dp的理由是
    //需要控制两个值，分别是
    //从起点到当前结点路径的和，和越大可以抵消的伤害就越大
    //从起点到当前结点路径所需的最小初始值即骑士最少需要多少血才不会暴毙
    //希望路径的和尽可能大，而初始值尽可能小
    //这两个值同样重要，导致在dp选择环节中无法取舍，这个理由比局部最优不是全局最优充分的多
    //考虑从后往前dp，令dp[i][j]表示(i, j)到终点的最小初始值
    //当到达(i, j)时，如果路径和不小于dp[i][j]，就能达到终点
    //只需要关心最小值，即min(dp[i + 1][j], dp[i][j + 1])
    //dp[i][j] + dungeon[i][j]必须大于min(dp[i + 1][j], dp[i][j + 1])
    //或者至少为1才能继续往后走
    //dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) − dungeon[i][j], 1)
    //最终答案为dp[0][0]
    //当i或j到达边界时，i + 1和j + 1都会越界
    //为二维数组多加一行一列，因为会过滤掉大的值，所以将其设为Integer.MAX_VALUE
    //而对于终点P，dp[i + 1][j], dp[i][j + 1]都为极大值时会使用极大值进入max判断
    //所以将其设为1
    class Solution {
        public int calculateMinimumHP(int[][] dungeon) {
            int n = dungeon.length, m = dungeon[0].length;
            int[][] dp = new int[n + 1][m + 1];
            for (int i = 0; i <= n; ++i) {
                Arrays.fill(dp[i], Integer.MAX_VALUE);
            }
            dp[n][m - 1] = dp[n - 1][m] = 1;
            for (int i = n - 1; i >= 0; --i) {
                for (int j = m - 1; j >= 0; --j) {
                    int minn = Math.min(dp[i + 1][j], dp[i][j + 1]);
                    dp[i][j] = Math.max(minn - dungeon[i][j], 1);
                }
            }
            return dp[0][0];
        }
    }

    public static void main(String[] args) {
        _174 q = new _174();
        int[][] dungeon = {
                {-2, -3, 3},
                {-5, -10, 1},
                {10, 30, -5}
        };
        System.out.println(q.new Solution().calculateMinimumHP(dungeon));
    }
}
